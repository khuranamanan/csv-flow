{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "csv-flow",
  "type": "registry:block",
  "title": "CSV Flow",
  "author": "Manan Khurana <khuranamanan12@gmail.com>",
  "description": "A Component that makes importing CSV files into applications easier with validations.",
  "dependencies": [
    "date-fns",
    "nanoid",
    "papaparse",
    "@types/papaparse",
    "react-dropzone",
    "@tanstack/react-table",
    "@tanstack/react-virtual"
  ],
  "registryDependencies": [
    "button",
    "checkbox",
    "dialog",
    "form",
    "label",
    "progress",
    "scroll-area",
    "select",
    "separator",
    "sonner",
    "switch",
    "table",
    "tooltip"
  ],
  "files": [
    {
      "path": "src/features/csv-flow/index.tsx",
      "content": "import { Dialog, DialogContent, DialogHeader } from \"@/components/ui/dialog\";\nimport { memo, useCallback, useState } from \"react\";\nimport MapStep from \"./components/map-step\";\nimport { ReviewStep } from \"./components/review-step\";\nimport StepIndicator from \"./components/step-indicator\";\nimport {\n  CsvColumn,\n  CsvFlowProps,\n  FieldMappingItem,\n  Meta,\n  StepItems,\n} from \"./types\";\nimport UploadStep from \"./components/upload-step\";\n\nexport type FlowSteps =\n  | {\n      step: StepItems.Upload;\n    }\n  | {\n      step: StepItems.Map;\n      data: Record<string, string>[];\n      columns: CsvColumn[];\n    }\n  | {\n      step: StepItems.Review;\n      data: (Record<string, unknown> & Meta)[];\n      fieldMappings: FieldMappingItem[];\n    };\n\nfunction CsvFlow(props: CsvFlowProps) {\n  const {\n    open,\n    setOpen,\n    fields,\n    maxRows = 1000,\n    maxFileSize = 1024 * 1024 * 2,\n    enableCustomFields = false,\n    customFieldReturnType = \"object\",\n    showTemplateDownload = true,\n    onImport,\n  } = props;\n\n  const [currentStep, setCurrentStep] = useState<FlowSteps>({\n    step: StepItems.Upload,\n  });\n\n  const renderStep = useCallback(() => {\n    switch (currentStep.step) {\n      case StepItems.Upload:\n        return (\n          <UploadStep\n            fields={fields}\n            maxRows={maxRows}\n            setStep={setCurrentStep}\n            maxFileSize={maxFileSize}\n            showTemplateDownload={showTemplateDownload}\n          />\n        );\n      case StepItems.Map:\n        return (\n          <MapStep\n            fields={fields}\n            data={currentStep.data}\n            columns={currentStep.columns}\n            setStep={setCurrentStep}\n            enableCustomFields={enableCustomFields}\n          />\n        );\n\n      case StepItems.Review:\n        return (\n          <ReviewStep\n            data={currentStep.data}\n            fields={fields}\n            fieldMappings={currentStep.fieldMappings}\n            enableCustomFields={enableCustomFields}\n            customFieldReturnType={customFieldReturnType}\n            onImport={onImport}\n            handleCloseDialog={() => {\n              setOpen(false);\n              setCurrentStep({\n                step: StepItems.Upload,\n              });\n            }}\n          />\n        );\n      default:\n        return null;\n    }\n  }, [\n    currentStep,\n    fields,\n    maxRows,\n    maxFileSize,\n    customFieldReturnType,\n    enableCustomFields,\n    showTemplateDownload,\n    onImport,\n    setOpen,\n  ]);\n\n  return (\n    <Dialog\n      modal\n      open={open}\n      onOpenChange={(isOpen) => {\n        setOpen(isOpen);\n        if (!isOpen) {\n          setCurrentStep({ step: StepItems.Upload });\n        }\n      }}\n    >\n      <DialogContent\n        className=\"h-[90vh] w-[90vw] max-w-[90vw] sm:max-w-[90vw] flex flex-col\"\n        onInteractOutside={(e) => {\n          e.preventDefault();\n        }}\n      >\n        <DialogHeader className=\"pb-6 border-b\">\n          <div className=\"flex space-x-4\">\n            <StepIndicator\n              number={1}\n              text=\"Upload a CSV file\"\n              description=\"Upload a CSV file to get started\"\n              active={currentStep.step === StepItems.Upload}\n            />\n            <StepIndicator\n              number={2}\n              text=\"Map fields\"\n              description=\"Map fields to the corresponding columns\"\n              active={currentStep.step === StepItems.Map}\n            />\n            <StepIndicator\n              number={3}\n              text=\"Review data\"\n              description=\"Review the data before importing\"\n              active={currentStep.step === StepItems.Review}\n            />\n          </div>\n        </DialogHeader>\n\n        <div className=\"grow overflow-hidden\">{renderStep()}</div>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\nexport default memo(CsvFlow);\n",
      "type": "registry:block",
      "target": "components/csv-flow/index.tsx"
    },
    {
      "path": "src/features/csv-flow/types/index.ts",
      "content": "export type CustomFieldReturnType = \"object\" | \"json\" | \"flat\";\r\n\r\n/**\r\n * Props for the CSV Flow component.\r\n *\r\n * @interface CsvFlowProps\r\n *\r\n * @property {boolean} open - Indicates whether the CSV flow dialog is open.\r\n * @property {(v: boolean) => void} setOpen - Callback function to update the open state.\r\n * @property {FieldConfig[]} fields - An array of field configuration objects used to map CSV columns.\r\n *   Each object should include:\r\n *   - **columnName**: The internal name of the field (e.g., \"Name\", \"Email\") (Key that will be used when data is returned).\r\n *   - **displayName** (optional): A user-friendly name for the field. If omitted, `columnName` is used.\r\n *   - **columnRequired**: A boolean indicating whether the field is mandatory.\r\n *   - **type**: The expected data type for the field. One of \"string\", \"number\", \"boolean\", \"email\", or \"date\".\r\n *   - **example** (optional): An example value to include in the CSV template download.\r\n *   - **validations** (optional): An array of validations to apply. Validations can be of the following types:\r\n *     - **UniqueValidation**: `{ rule: \"unique\", allowEmpty?: boolean, errorMessage?: string, level?: \"info\" | \"warning\" | \"error\" }`\r\n *     - **RegexValidation**: `{ rule: \"regex\", value: string, flags?: string, errorMessage: string, level?: \"info\" | \"warning\" | \"error\" }`\r\n *     - **CustomValidation**: `{ rule: \"custom\", validate: (value: unknown, row: Record<string, unknown>) => boolean, errorMessage: string, level?: \"info\" | \"warning\" | \"error\" }`\r\n *\r\n * **Error Levels:** Default \"error\".\r\n *   - **\"error\"**: A critical validation error that must be resolved before import can proceed.\r\n *   - **\"warning\"** or **\"info\"**: These indicate less issues that are only informational and\r\n *     will not block the import.\r\n *\r\n * @property {number} [maxRows] - Optional. Maximum number of data rows to process. Defaults to 1000.\r\n * @property {number} [maxFileSize] - Optional. Maximum allowed file size (in bytes)\r\n * for the CSV file uploader. Defaults to 2MB.\r\n *\r\n * @property {boolean} [enableCustomFields] - When true, enables the custom fields functionality in the importer. Default is false.\r\n * @property {CustomFieldReturnType} [customFieldReturnType] Specifies how custom fields should be returned in the final data.\r\n * - \"object\": (default) Custom fields are returned as an object attached to the main data (e.g. under a `customFields` key).\r\n * - \"json\": Custom fields are returned as a JSON string.\r\n * - \"flat\": Custom fields are merged directly into the top-level of the final object.\r\n * @property {boolean} [showTemplateDownload] - When true, shows the download template button in the upload step. Default is true.\r\n * @property onImport - Callback function invoked when the import operation is triggered.\r\n *                      It receives an array of objects, where each object represents a row of imported CSV data.\r\n *\r\n * @example\r\n * import { useState } from \"react\";\r\n * import CsvFlow from \"./features/csv-flow\";\r\n * import { someFieldConfigs } from \"./field-configurations\";\r\n *\r\n * function App() {\r\n *   const [open, setOpen] = useState(false);\r\n *\r\n *   return (\r\n *     <>\r\n *       <button onClick={() => setOpen(true)}>Open CSV Flow</button>\r\n *       <CsvFlow\r\n *         open={open}\r\n *         setOpen={setOpen}\r\n *         fields={someFieldConfigs}\r\n *         maxRows={500}         // Optional: override default max rows (default is 1000)\r\n *         maxFileSize={1024 * 1024} // Optional: override default max file size (default is 2MB)\r\n *         showTemplateDownload={true} // Optional: show download template button (default is true)\r\n *       />\r\n *     </>\r\n *   );\r\n * }\r\n */\r\nexport type CsvFlowProps = {\r\n  open: boolean;\r\n  setOpen: (v: boolean) => void;\r\n  fields: FieldConfig[];\r\n  maxRows?: number;\r\n  maxFileSize?: number;\r\n  enableCustomFields?: boolean;\r\n  customFieldReturnType?: CustomFieldReturnType;\r\n  showTemplateDownload?: boolean;\r\n  onImport: (data: Record<string, unknown>[]) => void;\r\n};\r\n\r\nexport enum StepItems {\r\n  Upload = \"Upload\",\r\n  Map = \"Map\",\r\n  Review = \"Review\",\r\n}\r\n\r\ntype FieldTypes = \"string\" | \"number\" | \"boolean\" | \"email\" | \"date\";\r\n\r\n/**\r\n * Configuration for a single field in the CSV.\r\n *\r\n * @interface FieldConfig\r\n * @property {string} columnName - The internal field name used for mapping (e.g., \"Name\", \"Email\").\r\n * @property {string} [displayName] - An optional human-friendly name for display purposes. If not provided, `columnName` is used.\r\n * @property {boolean} columnRequired - Indicates whether the field is mandatory.\r\n * @property {\"string\" | \"number\" | \"email\" | \"date\"} type - The expected data type for the field.\r\n * @property {Validation[]} [validations] - An array of additional validations to apply to this field.\r\n * @property {unknown} [example] - An optional example value to include in the CSV template.\r\n *\r\n * @example\r\n * const fieldConfig: FieldConfig = {\r\n *   columnName: \"email\",\r\n *   displayName: \"Email Address\",\r\n *   required: true,\r\n *   type: \"email\",\r\n *   example: \"john.doe@example.com\",\r\n *   validations: [\r\n *     {\r\n *       rule: \"regex\",\r\n *       value: \"^[\\\\w.-]+@[\\\\w.-]+\\\\.\\\\w+$\",\r\n *       errorMessage: \"Invalid email format\",\r\n *       level: \"error\"\r\n *     }\r\n *   ]\r\n * };\r\n */\r\nexport interface FieldConfig {\r\n  columnName: string; // The field name to map to (e.g., \"Name\", \"Email\")\r\n  displayName?: string;\r\n  columnRequired: boolean; // Whether the field is mandatory\r\n  type: FieldTypes;\r\n  validations?: Validation[];\r\n  example?: unknown; // Example value for CSV template\r\n}\r\n\r\n/**\r\n * A union type representing the various kinds of field validations.\r\n *\r\n * @typedef {RequiredValidation | UniqueValidation | RegexValidation} Validation\r\n */\r\ntype Validation = UniqueValidation | RegexValidation | CustomValidation;\r\n\r\n/**\r\n * Validation to ensure a field's value is unique across the dataset.\r\n *\r\n * @typedef {Object} UniqueValidation\r\n * @property {\"unique\"} rule - The rule identifier.\r\n * @property {boolean} [allowEmpty] - If true, empty values will be ignored in the uniqueness check.\r\n * @property {string} [errorMessage] - Optional custom error message.\r\n * @property {ErrorLevel} [level] - The severity level of the error.\r\n */\r\nexport type UniqueValidation = {\r\n  rule: \"unique\";\r\n  allowEmpty?: boolean;\r\n  errorMessage?: string;\r\n  level?: ErrorLevel;\r\n};\r\n\r\n/**\r\n * Validation using a regular expression.\r\n *\r\n * @typedef {Object} RegexValidation\r\n * @property {\"regex\"} rule - The rule identifier.\r\n * @property {string} value - The regular expression pattern to test against.\r\n * @property {string} [flags] - Optional regex flags (e.g., \"i\" for case-insensitive).\r\n * @property {string} errorMessage - The error message to display if validation fails.\r\n * @property {ErrorLevel} [level] - The severity level of the error.\r\n */\r\nexport type RegexValidation = {\r\n  rule: \"regex\";\r\n  value: string;\r\n  flags?: string;\r\n  errorMessage: string;\r\n  level?: ErrorLevel;\r\n};\r\n\r\n/**\r\n *\r\n */\r\n/**\r\n * Represents a custom validation rule.\r\n *\r\n * @typedef {object} CustomValidation\r\n *\r\n * @property {\"custom\"} rule - A literal string indicating this is a custom validation rule.\r\n * @property {(value: unknown, row: Record<string, unknown>) => boolean} validate -\r\n *   The validation function that takes a value and its associated row, returning true if the value passes the validation, otherwise false.\r\n * @property {string} errorMessage - The error message to be displayed when the validation fails.\r\n * @property {ErrorLevel} [level] - An optional property representing the level of the error.\r\n */\r\nexport type CustomValidation = {\r\n  rule: \"custom\";\r\n  validate: (value: unknown, row: Record<string, unknown>) => boolean;\r\n  errorMessage: string;\r\n  level?: ErrorLevel;\r\n};\r\n\r\n/**\r\n * The severity level for a validation error.\r\n *\r\n * @typedef {\"info\" | \"warning\" | \"error\"} ErrorLevel\r\n */\r\nexport type ErrorLevel = \"info\" | \"warning\" | \"error\";\r\n\r\ntype Info = {\r\n  message: string;\r\n  level: ErrorLevel;\r\n};\r\n\r\nexport enum ErrorSources {\r\n  Table = \"table\",\r\n  Row = \"row\",\r\n}\r\n\r\nexport type InfoWithSource = Info & {\r\n  source: ErrorSources;\r\n};\r\n\r\nexport type Meta = { __index: string; __errors?: Error | null };\r\nexport type Error = { [key: string]: InfoWithSource };\r\n// export type Errors = { [id: string]: Error };\r\n\r\nexport enum FieldStatus {\r\n  Unmapped = \"Unmapped\",\r\n  Custom = \"Custom\",\r\n  Mapped = \"Mapped\",\r\n  Ignored = \"Ignored\",\r\n}\r\n\r\nexport type FieldMappingItem = {\r\n  id: string;\r\n  csvValue: string;\r\n} & (\r\n  | {\r\n      status: FieldStatus.Mapped;\r\n      mappedValue: string;\r\n      type: FieldTypes;\r\n      displayName?: string;\r\n    }\r\n  | {\r\n      status: FieldStatus.Custom;\r\n      mappedValue: string;\r\n    }\r\n  | { status: FieldStatus.Unmapped | FieldStatus.Ignored }\r\n);\r\n\r\nexport type CsvColumn = { id: string; column: string };\r\n\r\nexport type UpdateDataType = (\r\n  rowIndex: string,\r\n  columnName: string,\r\n  value: unknown\r\n) => void;\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/types/index.ts"
    },
    {
      "path": "src/features/csv-flow/components/file-uploader.tsx",
      "content": "import { FileText, Upload, X } from \"lucide-react\";\r\nimport * as React from \"react\";\r\nimport Dropzone, {\r\n  type DropzoneProps,\r\n  type FileRejection,\r\n} from \"react-dropzone\";\r\nimport { toast } from \"sonner\";\r\n\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Progress } from \"@/components/ui/progress\";\r\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\r\nimport { useControllableState } from \"../hooks/use-controllable-state\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { formatBytes } from \"../utils/helpers\";\r\n\r\ninterface FileUploaderProps extends React.HTMLAttributes<HTMLDivElement> {\r\n  /**\r\n   * Value of the uploader.\r\n   * @type File[]\r\n   * @default undefined\r\n   * @example value={files}\r\n   */\r\n  value?: File[];\r\n\r\n  /**\r\n   * Function to be called when the value changes.\r\n   * @type (files: File[]) => void\r\n   * @default undefined\r\n   * @example onValueChange={(files) => setFiles(files)}\r\n   */\r\n  onValueChange?: (files: File[]) => void;\r\n\r\n  /**\r\n   * Function to be called when files are uploaded.\r\n   * @type (files: File[]) => Promise<void>\r\n   * @default undefined\r\n   * @example onUpload={(files) => uploadFiles(files)}\r\n   */\r\n  onUpload?: (files: File[]) => Promise<void>;\r\n\r\n  /**\r\n   * Progress of the uploaded files.\r\n   * @type Record<string, number> | undefined\r\n   * @default undefined\r\n   * @example progresses={{ \"file1.png\": 50 }}\r\n   */\r\n  progresses?: Record<string, number>;\r\n\r\n  /**\r\n   * Accepted file types for the uploader.\r\n   * @type { [key: string]: string[]}\r\n   * @default\r\n   * ```ts\r\n   * { \"image/*\": [] }\r\n   * ```\r\n   * @example accept={[\"image/png\", \"image/jpeg\"]}\r\n   */\r\n  accept?: DropzoneProps[\"accept\"];\r\n\r\n  /**\r\n   * Maximum file size for the uploader.\r\n   * @type number | undefined\r\n   * @default 1024 * 1024 * 2 // 2MB\r\n   * @example maxSize={1024 * 1024 * 2} // 2MB\r\n   */\r\n  maxSize?: DropzoneProps[\"maxSize\"];\r\n\r\n  /**\r\n   * Maximum number of files for the uploader.\r\n   * @type number | undefined\r\n   * @default 1\r\n   * @example maxFileCount={4}\r\n   */\r\n  maxFileCount?: DropzoneProps[\"maxFiles\"];\r\n\r\n  /**\r\n   * Whether the uploader should accept multiple files.\r\n   * @type boolean\r\n   * @default false\r\n   * @example multiple\r\n   */\r\n  multiple?: boolean;\r\n\r\n  /**\r\n   * Whether the uploader is disabled.\r\n   * @type boolean\r\n   * @default false\r\n   * @example disabled\r\n   */\r\n  disabled?: boolean;\r\n\r\n  /**\r\n   * Class name for the uploader container.\r\n   * @type string | undefined\r\n   * @default undefined\r\n   * @example containerClassName=\"h-96\"\r\n   */\r\n  containerClassName?: string;\r\n}\r\n\r\nexport function FileUploader(props: FileUploaderProps) {\r\n  const {\r\n    value: valueProp,\r\n    onValueChange,\r\n    onUpload,\r\n    progresses,\r\n    accept = {\r\n      \"image/*\": [],\r\n    },\r\n    maxSize = 1024 * 1024 * 2,\r\n    maxFileCount = 1,\r\n    multiple = false,\r\n    disabled = false,\r\n    className,\r\n    containerClassName,\r\n    ...dropzoneProps\r\n  } = props;\r\n\r\n  const [files, setFiles] = useControllableState({\r\n    prop: valueProp,\r\n    onChange: onValueChange,\r\n  });\r\n\r\n  const onDrop = React.useCallback(\r\n    (acceptedFiles: File[], rejectedFiles: FileRejection[]) => {\r\n      if (!multiple && maxFileCount === 1 && acceptedFiles.length > 1) {\r\n        toast.error(\"Cannot upload more than 1 file at a time\");\r\n        return;\r\n      }\r\n\r\n      if ((files?.length ?? 0) + acceptedFiles.length > maxFileCount) {\r\n        toast.error(`Cannot upload more than ${maxFileCount} files`);\r\n        return;\r\n      }\r\n\r\n      const newFiles = acceptedFiles.map((file) =>\r\n        Object.assign(file, {\r\n          preview: URL.createObjectURL(file),\r\n        })\r\n      );\r\n\r\n      const updatedFiles = files ? [...files, ...newFiles] : newFiles;\r\n\r\n      setFiles(updatedFiles);\r\n\r\n      if (rejectedFiles.length > 0) {\r\n        rejectedFiles.forEach(({ file }) => {\r\n          toast.error(`File ${file.name} was rejected`);\r\n        });\r\n      }\r\n\r\n      if (\r\n        onUpload &&\r\n        updatedFiles.length > 0 &&\r\n        updatedFiles.length <= maxFileCount\r\n      ) {\r\n        const target =\r\n          updatedFiles.length > 0 ? `${updatedFiles.length} files` : `file`;\r\n\r\n        toast.promise(onUpload(updatedFiles), {\r\n          loading: `Uploading ${target}...`,\r\n          success: () => {\r\n            setFiles([]);\r\n            return `${target} uploaded`;\r\n          },\r\n          error: `Failed to upload ${target}`,\r\n        });\r\n      }\r\n    },\r\n\r\n    [files, maxFileCount, multiple, onUpload, setFiles]\r\n  );\r\n\r\n  function onRemove(index: number) {\r\n    if (!files) return;\r\n    const newFiles = files.filter((_, i) => i !== index);\r\n    setFiles(newFiles);\r\n    onValueChange?.(newFiles);\r\n  }\r\n\r\n  // Revoke preview url when component unmounts\r\n  React.useEffect(() => {\r\n    return () => {\r\n      if (!files) return;\r\n      files.forEach((file) => {\r\n        if (isFileWithPreview(file)) {\r\n          URL.revokeObjectURL(file.preview);\r\n        }\r\n      });\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  const isDisabled = disabled || (files?.length ?? 0) >= maxFileCount;\r\n\r\n  return (\r\n    <div\r\n      className={cn(\r\n        \"flex overflow-hidden relative flex-col gap-6\",\r\n        containerClassName\r\n      )}\r\n    >\r\n      <Dropzone\r\n        onDrop={onDrop}\r\n        accept={accept}\r\n        maxSize={maxSize}\r\n        maxFiles={maxFileCount}\r\n        multiple={maxFileCount > 1 || multiple}\r\n        disabled={isDisabled}\r\n      >\r\n        {({ getRootProps, getInputProps, isDragActive }) => (\r\n          <div\r\n            {...getRootProps()}\r\n            className={cn(\r\n              \"group relative grid h-52 w-full cursor-pointer place-items-center rounded-lg border-2 border-dashed border-muted-foreground/25 px-5 py-2.5 text-center transition hover:bg-muted/25\",\r\n              \"ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\r\n              isDragActive && \"border-muted-foreground/50\",\r\n              isDisabled && \"pointer-events-none opacity-60\",\r\n              className\r\n            )}\r\n            {...dropzoneProps}\r\n          >\r\n            <input {...getInputProps()} />\r\n            {isDragActive ? (\r\n              <div className=\"flex flex-col gap-4 justify-center items-center sm:px-5\">\r\n                <div className=\"p-3 rounded-full border border-dashed\">\r\n                  <Upload\r\n                    className=\"size-7 text-muted-foreground\"\r\n                    aria-hidden=\"true\"\r\n                  />\r\n                </div>\r\n                <p className=\"font-medium text-muted-foreground\">\r\n                  Drop the files here\r\n                </p>\r\n              </div>\r\n            ) : (\r\n              <div className=\"flex flex-col gap-4 justify-center items-center sm:px-5\">\r\n                <div className=\"p-3 rounded-full border border-dashed\">\r\n                  <Upload\r\n                    className=\"size-7 text-muted-foreground\"\r\n                    aria-hidden=\"true\"\r\n                  />\r\n                </div>\r\n                <div className=\"flex flex-col gap-px\">\r\n                  <p className=\"font-medium text-muted-foreground\">\r\n                    Drag {`'n'`} drop files here, or click to select files\r\n                  </p>\r\n                  <p className=\"text-sm text-muted-foreground/70\">\r\n                    You can upload\r\n                    {maxFileCount > 1\r\n                      ? ` ${\r\n                          maxFileCount === Infinity ? \"multiple\" : maxFileCount\r\n                        }\r\n                      files (up to ${formatBytes(maxSize)} each)`\r\n                      : ` a file with ${formatBytes(maxSize)}`}\r\n                  </p>\r\n                </div>\r\n              </div>\r\n            )}\r\n          </div>\r\n        )}\r\n      </Dropzone>\r\n\r\n      {files?.length ? (\r\n        <ScrollArea className=\"w-full h-fit\">\r\n          <div className=\"flex flex-col gap-4 max-h-48 border\">\r\n            {files?.map((file, index) => (\r\n              <FileCard\r\n                key={index}\r\n                file={file}\r\n                onRemove={() => onRemove(index)}\r\n                progress={progresses?.[file.name]}\r\n              />\r\n            ))}\r\n          </div>\r\n        </ScrollArea>\r\n      ) : null}\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface FileCardProps {\r\n  file: File;\r\n  onRemove: () => void;\r\n  progress?: number;\r\n}\r\n\r\nfunction FileCard({ file, progress, onRemove }: FileCardProps) {\r\n  return (\r\n    <div className=\"relative flex items-center gap-2.5 p-2 rounded\">\r\n      <div className=\"flex flex-1 gap-2.5\">\r\n        {isFileWithPreview(file) ? <FilePreview file={file} /> : null}\r\n        <div className=\"flex flex-col gap-2 w-full\">\r\n          <div className=\"flex flex-col gap-px\">\r\n            <p className=\"text-sm font-medium line-clamp-1 text-foreground/80\">\r\n              {file.name}\r\n            </p>\r\n            <p className=\"text-xs text-muted-foreground\">\r\n              {formatBytes(file.size)}\r\n            </p>\r\n          </div>\r\n          {progress ? <Progress value={progress} /> : null}\r\n        </div>\r\n      </div>\r\n      <div className=\"flex gap-2 items-center\">\r\n        <Button\r\n          type=\"button\"\r\n          variant=\"outline\"\r\n          size=\"icon\"\r\n          className=\"size-7\"\r\n          onClick={onRemove}\r\n        >\r\n          <X className=\"size-4\" aria-hidden=\"true\" />\r\n          <span className=\"sr-only\">Remove file</span>\r\n        </Button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction isFileWithPreview(file: File): file is File & { preview: string } {\r\n  return \"preview\" in file && typeof file.preview === \"string\";\r\n}\r\n\r\ninterface FilePreviewProps {\r\n  file: File & { preview: string };\r\n}\r\n\r\nfunction FilePreview({ file }: FilePreviewProps) {\r\n  if (file.type.startsWith(\"image/\")) {\r\n    return (\r\n      <img\r\n        src={file.preview}\r\n        alt={file.name}\r\n        width={48}\r\n        height={48}\r\n        loading=\"lazy\"\r\n        className=\"object-cover rounded-md aspect-square shrink-0\"\r\n      />\r\n    );\r\n  }\r\n\r\n  return (\r\n    <FileText className=\"size-10 text-muted-foreground\" aria-hidden=\"true\" />\r\n  );\r\n}\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/components/file-uploader.tsx"
    },
    {
      "path": "src/features/csv-flow/hooks/use-callback-ref.tsx",
      "content": "import * as React from \"react\";\r\n\r\n/**\r\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/use-callback-ref/src/useCallbackRef.tsx\r\n */\r\n\r\n/**\r\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\r\n * prop or avoid re-executing effects when passed as a dependency\r\n */\r\nfunction useCallbackRef<T extends (...args: never[]) => unknown>(\r\n  callback: T | undefined\r\n): T {\r\n  const callbackRef = React.useRef(callback);\r\n\r\n  React.useEffect(() => {\r\n    callbackRef.current = callback;\r\n  });\r\n\r\n  // https://github.com/facebook/react/issues/19240\r\n  return React.useMemo(\r\n    () => ((...args) => callbackRef.current?.(...args)) as T,\r\n    []\r\n  );\r\n}\r\n\r\nexport { useCallbackRef };\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/hooks/use-callback-ref.tsx"
    },
    {
      "path": "src/features/csv-flow/hooks/use-controllable-state.tsx",
      "content": "import * as React from \"react\";\r\n\r\nimport { useCallbackRef } from \"./use-callback-ref\";\r\n\r\n/**\r\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx\r\n */\r\n\r\ntype UseControllableStateParams<T> = {\r\n  prop?: T | undefined;\r\n  defaultProp?: T | undefined;\r\n  onChange?: (state: T) => void;\r\n};\r\n\r\ntype SetStateFn<T> = (prevState?: T) => T;\r\n\r\nfunction useControllableState<T>({\r\n  prop,\r\n  defaultProp,\r\n  onChange = () => {},\r\n}: UseControllableStateParams<T>) {\r\n  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({\r\n    defaultProp,\r\n    onChange,\r\n  });\r\n  const isControlled = prop !== undefined;\r\n  const value = isControlled ? prop : uncontrolledProp;\r\n  const handleChange = useCallbackRef(onChange);\r\n\r\n  const setValue: React.Dispatch<React.SetStateAction<T | undefined>> =\r\n    React.useCallback(\r\n      (nextValue) => {\r\n        if (isControlled) {\r\n          const setter = nextValue as SetStateFn<T>;\r\n          const value =\r\n            typeof nextValue === \"function\" ? setter(prop) : nextValue;\r\n          if (value !== prop) handleChange(value as T);\r\n        } else {\r\n          setUncontrolledProp(nextValue);\r\n        }\r\n      },\r\n      [isControlled, prop, setUncontrolledProp, handleChange]\r\n    );\r\n\r\n  return [value, setValue] as const;\r\n}\r\n\r\nfunction useUncontrolledState<T>({\r\n  defaultProp,\r\n  onChange,\r\n}: Omit<UseControllableStateParams<T>, \"prop\">) {\r\n  const uncontrolledState = React.useState<T | undefined>(defaultProp);\r\n  const [value] = uncontrolledState;\r\n  const prevValueRef = React.useRef(value);\r\n  const handleChange = useCallbackRef(onChange);\r\n\r\n  React.useEffect(() => {\r\n    if (prevValueRef.current !== value) {\r\n      handleChange(value as T);\r\n      prevValueRef.current = value;\r\n    }\r\n  }, [value, prevValueRef, handleChange]);\r\n\r\n  return uncontrolledState;\r\n}\r\n\r\nexport { useControllableState };\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/hooks/use-controllable-state.tsx"
    },
    {
      "path": "src/features/csv-flow/components/upload-step.tsx",
      "content": "import { FileUploader } from \"../components/file-uploader\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { DialogFooter } from \"@/components/ui/dialog\";\r\nimport { Separator } from \"@/components/ui/separator\";\r\nimport {\r\n  Table,\r\n  TableBody,\r\n  TableCell,\r\n  TableHead,\r\n  TableHeader,\r\n  TableRow,\r\n} from \"@/components/ui/table\";\r\nimport { parseCsv } from \"../utils/csv-parse\";\r\nimport { Check, Loader, Download } from \"lucide-react\";\r\nimport { useState } from \"react\";\r\nimport { toast } from \"sonner\";\r\nimport { FlowSteps } from \"..\";\r\nimport { FieldConfig, StepItems } from \"../types\";\r\nimport { formatBytes, toHeaderCase } from \"../utils/helpers\";\r\nimport {\r\n  generateCsvTemplate,\r\n  downloadCsvTemplate,\r\n} from \"../utils/template-generator\";\r\n\r\ntype Props = {\r\n  fields: FieldConfig[];\r\n  maxRows: number;\r\n  setStep: React.Dispatch<React.SetStateAction<FlowSteps>>;\r\n  maxFileSize: number;\r\n  showTemplateDownload?: boolean;\r\n};\r\n\r\nfunction UploadStep(props: Props) {\r\n  const {\r\n    fields,\r\n    maxRows,\r\n    setStep,\r\n    maxFileSize,\r\n    showTemplateDownload = true,\r\n  } = props;\r\n  const [processing, setProcessing] = useState(false);\r\n\r\n  const [files, setFiles] = useState<File[]>([]);\r\n\r\n  function handleDownloadTemplate() {\r\n    if (!fields || fields.length === 0) {\r\n      toast.error(\"No field configurations available for template generation\");\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const csvContent = generateCsvTemplate(fields, true);\r\n      downloadCsvTemplate(csvContent, \"csv-template.csv\");\r\n      toast.success(\"Template downloaded successfully!\");\r\n    } catch (error) {\r\n      toast.error(\"Failed to generate template\");\r\n      console.error(\"Template generation error:\", error);\r\n    }\r\n  }\r\n\r\n  async function onNextStepClick() {\r\n    setProcessing(true);\r\n    try {\r\n      const parsedResult = await parseCsv({ file: files[0], limit: maxRows });\r\n      // await new Promise<void>((resolve) => setTimeout(resolve, 10000));\r\n      toast.success(\"CSV parsed successfully!\");\r\n      setStep({\r\n        step: StepItems.Map,\r\n        ...parsedResult,\r\n      });\r\n    } catch (error) {\r\n      toast.error(error instanceof Error ? error.message : \"Parsing failed.\");\r\n    } finally {\r\n      setProcessing(false);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex flex-col gap-4 h-full\">\r\n      <div className=\"grid overflow-y-auto grid-cols-1 gap-6 grow md:grid-cols-3\">\r\n        <div className=\"col-span-2 h-full\">\r\n          <FileUploader\r\n            maxFileCount={1}\r\n            maxSize={maxFileSize}\r\n            onValueChange={setFiles}\r\n            containerClassName=\"h-full\"\r\n            className=\"flex-1\"\r\n            accept={{\r\n              \"text/csv\": [\".csv\"],\r\n            }}\r\n          />\r\n        </div>\r\n        <div>\r\n          <div className=\"flex flex-col gap-2 mb-4\">\r\n            <p className=\"p-2 text-sm text-center rounded-lg text-muted-foreground bg-muted\">\r\n              Max file size: {formatBytes(maxFileSize)}, Max rows: {maxRows}\r\n            </p>\r\n            {showTemplateDownload && (\r\n              <Button\r\n                type=\"button\"\r\n                variant=\"outline\"\r\n                size=\"sm\"\r\n                onClick={handleDownloadTemplate}\r\n                className=\"flex gap-2 items-center w-full\"\r\n              >\r\n                <Download className=\"size-4\" />\r\n                Download Template\r\n              </Button>\r\n            )}\r\n          </div>\r\n          <Separator className=\"my-2\" />\r\n          <Table>\r\n            <TableHeader>\r\n              <TableRow>\r\n                <TableHead>Expected Column</TableHead>\r\n                <TableHead>Expected Type</TableHead>\r\n                <TableHead>Required</TableHead>\r\n              </TableRow>\r\n            </TableHeader>\r\n            <TableBody>\r\n              {fields.map((field) => (\r\n                <TableRow key={field.columnName}>\r\n                  <TableCell>{field.displayName || field.columnName}</TableCell>\r\n                  <TableCell>{toHeaderCase(field.type)}</TableCell>\r\n                  <TableCell>\r\n                    {field.columnRequired ? <Check size={16} /> : null}\r\n                  </TableCell>\r\n                </TableRow>\r\n              ))}\r\n            </TableBody>\r\n          </Table>\r\n        </div>\r\n      </div>\r\n\r\n      <DialogFooter>\r\n        {processing && (\r\n          <p className=\"flex gap-2 items-center mr-4 text-sm text-muted-foreground\">\r\n            <Loader className=\"animate-spin size-4\" /> Processing...\r\n          </p>\r\n        )}\r\n        <Button\r\n          onClick={onNextStepClick}\r\n          disabled={files.length === 0 || processing}\r\n        >\r\n          Next\r\n        </Button>\r\n      </DialogFooter>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UploadStep;\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/components/upload-step.tsx"
    },
    {
      "path": "src/features/csv-flow/components/step-indicator.tsx",
      "content": "import { DialogDescription, DialogTitle } from \"@/components/ui/dialog\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\ntype Props = {\r\n  number: number;\r\n  text: string;\r\n  description?: string;\r\n  active: boolean;\r\n};\r\n\r\nfunction StepIndicator(props: Props) {\r\n  const { number, text, description, active } = props;\r\n\r\n  return (\r\n    <div className=\"flex items-center space-x-2\">\r\n      <div\r\n        className={`rounded-full w-8 h-8 flex items-center justify-center text-sm font-medium ${\r\n          active\r\n            ? \"bg-primary text-primary-foreground\"\r\n            : \"bg-muted text-muted-foreground\"\r\n        }`}\r\n      >\r\n        {number}\r\n      </div>\r\n      <div\r\n        className={cn(\"hidden sm:flex flex-col\", {\r\n          \"text-primary\": active,\r\n          \"text-muted-foreground\": !active,\r\n        })}\r\n      >\r\n        {active ? (\r\n          <>\r\n            <DialogTitle className=\"font-normal leading-normal\">\r\n              {text}\r\n            </DialogTitle>\r\n            <DialogDescription className=\"text-xs\">\r\n              {description}\r\n            </DialogDescription>\r\n          </>\r\n        ) : (\r\n          <>\r\n            <span className=\"text-lg font-normal tracking-normal\">{text}</span>\r\n            <span className=\"text-xs\">{description}</span>\r\n          </>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default StepIndicator;\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/components/step-indicator.tsx"
    },
    {
      "path": "src/features/csv-flow/components/map-step.tsx",
      "content": "import { Button } from \"@/components/ui/button\";\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormMessage,\n} from \"@/components/ui/form\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from \"@/components/ui/table\";\nimport { addErrorsToData, mapCsvRow } from \"../utils/map-utils\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { Loader } from \"lucide-react\";\nimport { nanoid } from \"nanoid\";\nimport { useState } from \"react\";\nimport { useForm } from \"react-hook-form\";\nimport { toast } from \"sonner\";\nimport { z } from \"zod\";\nimport { FlowSteps } from \"..\";\nimport {\n  CsvColumn,\n  FieldConfig,\n  FieldMappingItem,\n  FieldStatus,\n  Meta,\n  StepItems,\n} from \"../types\";\n\nconst IGNORE_FIELD_VALUE = \"IGNORE_FIELD\";\nconst CUSTOM_FIELD_VALUE = \"CUSTOM_FIELD\";\n\n/**\n * Transforms CSV data by mapping each row using the field mappings,\n * then applying validations based on the field configuration.\n */\nasync function mapData(\n  fieldMappings: FieldMappingItem[],\n  fields: FieldConfig[],\n  data: Record<string, unknown>[]\n): Promise<(Record<string, string> & Meta)[]> {\n  try {\n    const mappedRows = data.map((row) => mapCsvRow(row, fieldMappings));\n    const validatedData = await addErrorsToData(\n      mappedRows,\n      fields,\n      fieldMappings\n    );\n    return validatedData as (Record<string, string> & Meta)[];\n  } catch (error) {\n    console.error(\"Error mapping data:\", error);\n    throw new Error(\"Failed to map and validate data\");\n  }\n}\n\ntype MapStepProps = {\n  fields: FieldConfig[];\n  data: Record<string, string>[];\n  columns: CsvColumn[];\n  setStep: React.Dispatch<React.SetStateAction<FlowSteps>>;\n  enableCustomFields?: boolean;\n};\n\nconst mappingSchema = z.object({\n  mappings: z.record(z.string()),\n});\n\nfunction MapStep(props: MapStepProps) {\n  const { fields, data, columns, setStep, enableCustomFields } = props;\n\n  const [processing, setProcessing] = useState(false);\n\n  const defaultValues = {\n    mappings: columns.reduce(\n      (acc, col) => {\n        acc[col.id] = IGNORE_FIELD_VALUE;\n        return acc;\n      },\n      {} as Record<string, string>\n    ),\n  };\n\n  const form = useForm<z.infer<typeof mappingSchema>>({\n    resolver: zodResolver(mappingSchema),\n    defaultValues,\n  });\n\n  const fieldOptions = fields.map((field) => ({\n    value: field.columnName,\n    label:\n      (field.displayName || field.columnName) +\n      (field.columnRequired ? \" *\" : \"\"),\n  }));\n\n  const ignoreFieldOption = {\n    value: IGNORE_FIELD_VALUE,\n    label: \"Ignore Field\",\n  };\n\n  const customFieldOption = {\n    value: CUSTOM_FIELD_VALUE,\n    label: \"Custom Field\",\n  };\n\n  const additionalOptions = [\n    ignoreFieldOption,\n    ...(enableCustomFields ? [customFieldOption] : []),\n  ];\n\n  const onSubmit = async (values: z.infer<typeof mappingSchema>) => {\n    setProcessing(true);\n\n    const formValues = values.mappings;\n\n    const mappingCounts = Object.values(formValues).reduce(\n      (counts, mapping) => {\n        if (mapping !== IGNORE_FIELD_VALUE && mapping !== CUSTOM_FIELD_VALUE) {\n          counts[mapping] = (counts[mapping] || 0) + 1;\n        }\n        return counts;\n      },\n      {} as Record<string, number>\n    );\n\n    const duplicates = Object.entries(mappingCounts).filter(\n      ([, count]) => count > 1\n    );\n\n    if (duplicates.length > 0) {\n      toast.error(\n        `Each field can only be mapped once. Duplicate mapping for: ${duplicates\n          .map(([field]) => field)\n          .join(\", \")}`\n      );\n      setProcessing(false);\n      return;\n    }\n\n    const missingRequired = fields.filter(\n      (field) =>\n        field.columnRequired &&\n        !Object.values(formValues).includes(field.columnName)\n    );\n    if (missingRequired.length > 0) {\n      toast.error(\n        `Please map the required fields: ${missingRequired\n          .map((f) => f.displayName || f.columnName)\n          .join(\", \")}`\n      );\n      setProcessing(false);\n      return;\n    }\n\n    const fieldMappings: FieldMappingItem[] = columns.map((col) => {\n      const mappingOption = formValues[col.id];\n      if (mappingOption === IGNORE_FIELD_VALUE) {\n        return {\n          id: nanoid(),\n          csvValue: col.column,\n          status: FieldStatus.Ignored,\n        };\n      } else if (mappingOption === CUSTOM_FIELD_VALUE) {\n        return {\n          id: nanoid(),\n          csvValue: col.column,\n          status: FieldStatus.Custom,\n          mappedValue: col.column,\n        };\n      } else {\n        const field = fields.find((f) => f.columnName === mappingOption);\n        return {\n          id: nanoid(),\n          csvValue: col.column,\n          status: FieldStatus.Mapped,\n          mappedValue: mappingOption,\n          type: field?.type || \"string\",\n          displayName: field?.displayName,\n        };\n      }\n    });\n\n    try {\n      const mappedData = await mapData(fieldMappings, fields, data);\n      // await new Promise<void>((resolve) => setTimeout(resolve, 10000));\n      toast.success(\"Data mapped and validated successfully!\");\n      setStep({\n        step: StepItems.Review,\n        data: mappedData,\n        fieldMappings,\n      });\n    } catch (error) {\n      toast.error(\"Error mapping data: \" + (error as Error)?.message);\n    } finally {\n      setProcessing(false);\n    }\n  };\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      <p className=\"mb-2 text-sm\">\n        For each CSV column, select the field it should be mapped to.\n      </p>\n      <div className=\"p-2 mb-4 text-xs rounded-lg bg-muted text-muted-foreground\">\n        <p>\n          Expected Fields:{\" \"}\n          {fields.length === 1 ? (\n            <span>\n              {fields[0].displayName || fields[0].columnName}\n              {fields[0].columnRequired && \" (Required)\"}\n            </span>\n          ) : (\n            fields.map((field, index) => (\n              <span key={field.columnName}>\n                {field.displayName || field.columnName}\n                {field.columnRequired && \" (Required)\"}\n                {index < fields.length - 2\n                  ? \", \"\n                  : index === fields.length - 2\n                    ? \" & \"\n                    : \"\"}\n              </span>\n            ))\n          )}\n        </p>\n      </div>\n\n      <Form {...form}>\n        <form\n          onSubmit={form.handleSubmit(onSubmit)}\n          className=\"flex overflow-x-auto flex-col space-y-6 min-h-0\"\n        >\n          <div className=\"overflow-auto relative w-full text-sm rounded-md border grow scrollbar-thin scrollbar-thumb-muted-foreground/15 scrollbar-track-muted\">\n            <Table>\n              <TableHeader className=\"sticky top-0\">\n                <TableRow>\n                  <TableHead>CSV Column</TableHead>\n                  <TableHead>Sample Data</TableHead>\n                  <TableHead>Map to Field</TableHead>\n                </TableRow>\n              </TableHeader>\n              <TableBody>\n                {columns.map((col) => {\n                  const sampleValue =\n                    data\n                      .slice(0, 2)\n                      .map((row) => row[col.column])\n                      .filter(Boolean)\n                      .join(\", \") || \"\";\n                  return (\n                    <TableRow key={col.id}>\n                      <TableCell className=\"font-medium min-w-40\">\n                        {col.column}\n                      </TableCell>\n                      <TableCell>\n                        <p className=\"text-sm text-muted-foreground\">\n                          {sampleValue}\n                        </p>\n                      </TableCell>\n                      <TableCell className=\"min-w-80\">\n                        <FormField\n                          control={form.control}\n                          name={`mappings.${col.id}`}\n                          render={({ field }) => (\n                            <FormItem className=\"w-64\">\n                              <FormControl>\n                                <Select\n                                  onValueChange={field.onChange}\n                                  value={field.value}\n                                >\n                                  <SelectTrigger className=\"w-full\">\n                                    <SelectValue placeholder=\"Select mapping\" />\n                                  </SelectTrigger>\n                                  <SelectContent>\n                                    {fieldOptions.map((option) => (\n                                      <SelectItem\n                                        key={option.value}\n                                        value={option.value}\n                                      >\n                                        {option.label}\n                                      </SelectItem>\n                                    ))}\n                                    {additionalOptions.map((option) => (\n                                      <SelectItem\n                                        key={option.value}\n                                        value={option.value}\n                                      >\n                                        {option.label}\n                                      </SelectItem>\n                                    ))}\n                                  </SelectContent>\n                                </Select>\n                              </FormControl>\n                              <FormMessage />\n                            </FormItem>\n                          )}\n                        />\n                      </TableCell>\n                    </TableRow>\n                  );\n                })}\n              </TableBody>\n            </Table>\n          </div>\n          <div className=\"flex justify-end\">\n            {processing && (\n              <p className=\"flex gap-2 items-center mr-4 text-sm text-muted-foreground\">\n                <Loader className=\"animate-spin size-4\" /> Processing...\n              </p>\n            )}\n            <Button type=\"submit\" disabled={processing}>\n              Next\n            </Button>\n          </div>\n        </form>\n      </Form>\n    </div>\n  );\n}\n\nexport default MapStep;\n",
      "type": "registry:block",
      "target": "components/csv-flow/components/map-step.tsx"
    },
    {
      "path": "src/features/csv-flow/utils/csv-parse.ts",
      "content": "import { CsvColumn } from \"../types\";\r\nimport { nanoid } from \"nanoid\";\r\nimport Papa from \"papaparse\";\r\n\r\ninterface ParseCsvArgs {\r\n  file: File;\r\n  limit: number;\r\n  showEmptyFields?: boolean;\r\n  config?: Papa.ParseConfig;\r\n}\r\n\r\nexport async function parseCsv(\r\n  args: ParseCsvArgs\r\n): Promise<{ data: Record<string, string>[]; columns: CsvColumn[] }> {\r\n  const { file, config = {}, limit, showEmptyFields = true } = args;\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const parsedData: Record<string, string>[] = [];\r\n    let columns: string[] = [];\r\n    let rowCount = 0;\r\n    let abortedDueToLimit = false;\r\n\r\n    Papa.parse<Record<string, string>>(file, {\r\n      ...config,\r\n      header: true,\r\n      dynamicTyping: false,\r\n      skipEmptyLines: true,\r\n      beforeFirstChunk: (chunk) => {\r\n        const { updatedChunk, extractedColumns } = processFirstChunk(\r\n          chunk,\r\n          showEmptyFields\r\n        );\r\n        columns = extractedColumns;\r\n        return updatedChunk;\r\n      },\r\n      step: (results, parser) => {\r\n        if (rowCount < limit) {\r\n          parsedData.push(results.data);\r\n          rowCount++;\r\n        } else {\r\n          // Mark that we exceeded the row limit and abort the parsing.\r\n          abortedDueToLimit = true;\r\n          parser.abort();\r\n        }\r\n      },\r\n      complete: () => {\r\n        if (abortedDueToLimit) {\r\n          reject(\r\n            new Error(\r\n              `🚨 Row limit exceeded: Please upload a CSV file with a maximum of ${limit} rows.`\r\n            )\r\n          );\r\n        } else {\r\n          resolve({\r\n            data: parsedData,\r\n            columns: columns.map((v) => ({ id: nanoid(), column: v })),\r\n          });\r\n        }\r\n      },\r\n      error: (error) => reject(new Error(`Parsing failed: ${error.message}`)),\r\n    });\r\n\r\n    function processFirstChunk(\r\n      chunk: string,\r\n      showEmptyFields: boolean\r\n    ): { updatedChunk: string; extractedColumns: string[] } {\r\n      const parsed = Papa.parse<string[]>(chunk, {\r\n        header: false,\r\n        skipEmptyLines: true,\r\n      });\r\n      const rows = parsed.data;\r\n      const firstRow = rows[0] || [];\r\n\r\n      const processedColumns = firstRow\r\n        .map((col, i) => {\r\n          if (\r\n            !showEmptyFields &&\r\n            !rows.slice(1).some((row) => row[i]?.trim())\r\n          ) {\r\n            return null;\r\n          }\r\n          return col.trim() || `Field ${i + 1}`;\r\n        })\r\n        .filter(Boolean) as string[];\r\n\r\n      // Replace the first row with the processed columns.\r\n      rows[0] = processedColumns;\r\n      return {\r\n        updatedChunk: Papa.unparse(rows),\r\n        extractedColumns: processedColumns,\r\n      };\r\n    }\r\n  });\r\n}\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/utils/csv-parse.ts"
    },
    {
      "path": "src/features/csv-flow/utils/map-utils.ts",
      "content": "import { z, ZodTypeAny } from \"zod\";\r\nimport {\r\n  ErrorSources,\r\n  FieldConfig,\r\n  FieldMappingItem,\r\n  FieldStatus,\r\n  Meta,\r\n  Error as FieldError,\r\n  UniqueValidation,\r\n  CustomValidation,\r\n  RegexValidation,\r\n  InfoWithSource,\r\n  ErrorLevel,\r\n} from \"../types\";\r\nimport { nanoid } from \"nanoid\";\r\nimport { isValid } from \"date-fns\";\r\n\r\n/**\r\n * Maps a single CSV row using the provided field mappings.\r\n */\r\nexport function mapCsvRow(\r\n  row: Record<string, unknown>,\r\n  fieldMappings: FieldMappingItem[]\r\n): Record<string, unknown> {\r\n  const mappedRow: Record<string, unknown> = {};\r\n  fieldMappings.forEach((field) => {\r\n    if (\r\n      field.status === FieldStatus.Mapped ||\r\n      field.status === FieldStatus.Custom\r\n    ) {\r\n      mappedRow[field.mappedValue] = row[field.csvValue];\r\n    }\r\n  });\r\n  return mappedRow;\r\n}\r\n\r\n/**\r\n * Returns a Zod schema for a field based on its type and requirements.\r\n * Handles both base type validation and required field validation.\r\n */\r\nfunction getFieldSchema(field: FieldConfig): ZodTypeAny {\r\n  let schema: ZodTypeAny;\r\n\r\n  // Create base schema based on field type\r\n  switch (field.type) {\r\n    case \"number\":\r\n      schema = z.preprocess((val) => {\r\n        if (typeof val === \"string\") {\r\n          if (!val.trim()) return undefined;\r\n          const num = Number(val);\r\n          return isNaN(num) ? val : num;\r\n        }\r\n        return val;\r\n      }, z.number().optional());\r\n      break;\r\n    case \"boolean\":\r\n      schema = z.preprocess((val) => {\r\n        if (typeof val === \"string\") {\r\n          if (!val.trim()) return undefined;\r\n          const lower = val.toLowerCase();\r\n          if (lower === \"true\") return true;\r\n          if (lower === \"false\") return false;\r\n        }\r\n        return val;\r\n      }, z.boolean().optional());\r\n      break;\r\n    case \"date\":\r\n      schema = z.preprocess(\r\n        (val) => {\r\n          if (typeof val === \"string\") {\r\n            if (!val.trim()) return undefined;\r\n            return val;\r\n          }\r\n          return val;\r\n        },\r\n        z\r\n          .string()\r\n          .refine((val) => isValid(new Date(val)), {\r\n            message: \"Must be a valid date\",\r\n          })\r\n          .optional()\r\n      );\r\n      break;\r\n    case \"email\":\r\n      schema = z.preprocess((val) => {\r\n        if (typeof val === \"string\") {\r\n          if (!val.trim()) return undefined;\r\n          return val.trim();\r\n        }\r\n        return val;\r\n      }, z.string().email().optional());\r\n      break;\r\n    default:\r\n      schema = z.string().optional();\r\n  }\r\n\r\n  // Add required validation if needed\r\n  if (field.columnRequired) {\r\n    if (schema instanceof z.ZodString) {\r\n      schema = schema.min(1, { message: \"This field is required\" });\r\n    } else {\r\n      schema = schema.refine(\r\n        (val) => val !== undefined && val !== null && val !== \"\",\r\n        { message: \"This field is required\" }\r\n      );\r\n    }\r\n  }\r\n\r\n  return schema;\r\n}\r\n\r\n/**\r\n * Helper function to update an error for a field in an error object.\r\n * Only updates if the new error's level is higher than the current one.\r\n */\r\nfunction updateError(\r\n  fieldName: string,\r\n  newError: InfoWithSource,\r\n  errors: FieldError\r\n) {\r\n  const priority: Record<ErrorLevel, number> = {\r\n    info: 1,\r\n    warning: 2,\r\n    error: 3,\r\n  };\r\n  const current = errors[fieldName];\r\n  if (!current || priority[newError.level] > priority[current.level]) {\r\n    errors[fieldName] = newError;\r\n  }\r\n}\r\n\r\n/**\r\n * Applies validations to the mapped data using Zod for type validations.\r\n * After parsing each row with the generated row schema, any Zod errors are\r\n * converted to your expected error format. Then, we run custom (row-level)\r\n * validations, regex validations, and table-level unique validations.\r\n *\r\n * The `fieldMappings` parameter is used to determine if a given field is\r\n * actually mapped. If a field isn't mapped (status Unmapped/ Ignored),\r\n * unique validations for that field are skipped.\r\n */\r\nexport async function addErrorsToData(\r\n  data: Record<string, unknown>[],\r\n  fields: FieldConfig[],\r\n  fieldMappings: FieldMappingItem[]\r\n): Promise<(Record<string, unknown> & Meta)[]> {\r\n  function isFieldMapped(field: FieldConfig) {\r\n    return fieldMappings.some(\r\n      (mapping) =>\r\n        (mapping.status === FieldStatus.Mapped ||\r\n          mapping.status === FieldStatus.Custom) &&\r\n        mapping.mappedValue === field.columnName\r\n    );\r\n  }\r\n\r\n  const processedRows = data.map((row) => {\r\n    const newRow: Record<string, unknown> = { ...row };\r\n    const errors: FieldError = {};\r\n\r\n    // Type Validation\r\n    fields.forEach((field) => {\r\n      const value = row[field.columnName];\r\n      const schema = getFieldSchema(field);\r\n      const result = schema.safeParse(value);\r\n      if (result.success) {\r\n        newRow[field.columnName] = result.data;\r\n      } else {\r\n        newRow[field.columnName] = value;\r\n        updateError(\r\n          field.columnName,\r\n          {\r\n            message: result.error.issues[0].message,\r\n            level: \"error\",\r\n            source: ErrorSources.Row,\r\n          },\r\n          errors\r\n        );\r\n      }\r\n    });\r\n\r\n    // Custom and Regex Validations (only if field is mapped)\r\n    fields.forEach((field) => {\r\n      if (!isFieldMapped(field)) return;\r\n\r\n      // Skip validations if the field is empty and not required.\r\n      const fieldValue = newRow[field.columnName];\r\n      const isEmpty =\r\n        fieldValue === undefined || fieldValue === null || fieldValue === \"\";\r\n      if (isEmpty && !field.columnRequired) return;\r\n\r\n      // Custom Validations.\r\n      const customValidations = field.validations?.filter(\r\n        (v) => v.rule === \"custom\"\r\n      ) as CustomValidation[] | undefined;\r\n\r\n      if (customValidations) {\r\n        customValidations.forEach((validation) => {\r\n          if (!validation.validate(newRow[field.columnName], newRow)) {\r\n            updateError(\r\n              field.columnName,\r\n              {\r\n                message: validation.errorMessage,\r\n                level: validation.level || \"error\",\r\n                source: ErrorSources.Row,\r\n              },\r\n              errors\r\n            );\r\n          }\r\n        });\r\n      }\r\n\r\n      // Regex Validations.\r\n      const regexValidations = field.validations?.filter(\r\n        (v) => v.rule === \"regex\"\r\n      ) as RegexValidation[] | undefined;\r\n\r\n      if (regexValidations) {\r\n        regexValidations.forEach((validation) => {\r\n          const regex = new RegExp(validation.value, validation.flags);\r\n          if (!regex.test(String(newRow[field.columnName] || \"\"))) {\r\n            updateError(\r\n              field.columnName,\r\n              {\r\n                message: validation.errorMessage,\r\n                level: validation.level || \"error\",\r\n                source: ErrorSources.Row,\r\n              },\r\n              errors\r\n            );\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    return {\r\n      ...newRow,\r\n      __index: (row.__index as string) || nanoid(),\r\n      __errors: Object.keys(errors).length > 0 ? errors : null,\r\n    };\r\n  });\r\n\r\n  let result: (Record<string, unknown> & Meta)[] = processedRows;\r\n\r\n  // Unique Validation\r\n  fields.forEach((field) => {\r\n    const uniqueValidation = field.validations?.find(\r\n      (v) => v.rule === \"unique\"\r\n    ) as UniqueValidation | undefined;\r\n\r\n    if (uniqueValidation) {\r\n      const isMapped = isFieldMapped(field);\r\n      if (!isMapped) return;\r\n\r\n      const values = result.map((entry) => entry[field.columnName]);\r\n      const seen = new Set();\r\n      const duplicates = new Set();\r\n      values.forEach((val) => {\r\n        if (uniqueValidation.allowEmpty && (val === undefined || val === \"\"))\r\n          return;\r\n        if (seen.has(val)) {\r\n          duplicates.add(val);\r\n        } else {\r\n          seen.add(val);\r\n        }\r\n      });\r\n\r\n      result = result.map((entry) => {\r\n        if (duplicates.has(entry[field.columnName])) {\r\n          const currentErrors = entry.__errors || ({} as FieldError);\r\n          updateError(\r\n            field.columnName,\r\n            {\r\n              message: uniqueValidation.errorMessage || \"Field must be unique\",\r\n              level: uniqueValidation.level || \"error\",\r\n              source: ErrorSources.Table,\r\n            },\r\n            currentErrors\r\n          );\r\n          return { ...entry, __errors: currentErrors };\r\n        }\r\n        return entry;\r\n      });\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/utils/map-utils.ts"
    },
    {
      "path": "src/features/csv-flow/utils/helpers.ts",
      "content": "export function formatBytes(\r\n  bytes: number,\r\n  opts: {\r\n    decimals?: number;\r\n    sizeType?: \"accurate\" | \"normal\";\r\n  } = {}\r\n) {\r\n  const { decimals = 0, sizeType = \"normal\" } = opts;\r\n\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\r\n  const accurateSizes = [\"Bytes\", \"KiB\", \"MiB\", \"GiB\", \"TiB\"];\r\n  if (bytes === 0) return \"0 Byte\";\r\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\r\n  return `${(bytes / Math.pow(1024, i)).toFixed(decimals)} ${\r\n    sizeType === \"accurate\" ? accurateSizes[i] ?? \"Bytes\" : sizes[i] ?? \"Bytes\"\r\n  }`;\r\n}\r\n\r\nexport function toHeaderCase(str: string = \"\"): string {\r\n  if (!str) return \"\";\r\n\r\n  return String(str)\r\n    .replace(/^[^A-Za-z0-9]*|[^A-Za-z0-9]*$/g, \"\")\r\n    .replace(/([a-z])([A-Z])/g, (_, a, b) => `${a}_${b.toLowerCase()}`)\r\n    .replace(/[^A-Za-z0-9]+|_+/g, \" \")\r\n    .toLowerCase()\r\n    .replace(\r\n      /( ?)(\\w+)( ?)/g,\r\n      (_, a, b, c) => a + b.charAt(0).toUpperCase() + b.slice(1) + c\r\n    );\r\n}\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/utils/helpers.ts"
    },
    {
      "path": "src/features/csv-flow/utils/template-generator.ts",
      "content": "import { FieldConfig } from \"../types\";\r\n\r\n/**\r\n * Generates a CSV template with headers and optional example data\r\n * @param fields - Array of field configurations\r\n * @param includeExampleRow - Whether to include an example row with sample data\r\n * @returns CSV content as a string\r\n */\r\nexport function generateCsvTemplate(\r\n  fields: FieldConfig[],\r\n  includeExampleRow: boolean = true\r\n): string {\r\n  // Generate headers using displayName or columnName\r\n  const headers = fields.map((field) => field.displayName || field.columnName);\r\n\r\n  // Create CSV content\r\n  let csvContent = headers.join(\",\") + \"\\n\";\r\n\r\n  if (includeExampleRow) {\r\n    // Generate example row with example values or default values\r\n    const exampleRow = fields.map((field) => {\r\n      if (field.example !== undefined && field.example !== null) {\r\n        // Use provided example value, convert to string and escape if needed\r\n        const exampleString = convertToString(field.example);\r\n        return escapeCsvValue(exampleString);\r\n      }\r\n\r\n      // Generate default example based on field type\r\n      return generateDefaultExample(field.type);\r\n    });\r\n\r\n    csvContent += exampleRow.join(\",\") + \"\\n\";\r\n  }\r\n\r\n  return csvContent;\r\n}\r\n\r\n/**\r\n * Converts an unknown value to a string for CSV output\r\n * @param value - The value to convert\r\n * @returns String representation of the value\r\n */\r\nfunction convertToString(value: unknown): string {\r\n  if (typeof value === \"string\") {\r\n    return value;\r\n  }\r\n  if (typeof value === \"number\") {\r\n    return value.toString();\r\n  }\r\n  if (typeof value === \"boolean\") {\r\n    return value.toString();\r\n  }\r\n  if (value instanceof Date) {\r\n    return value.toISOString().split(\"T\")[0]; // YYYY-MM-DD format\r\n  }\r\n  if (value === null || value === undefined) {\r\n    return \"\";\r\n  }\r\n  // For objects, arrays, etc., convert to JSON string\r\n  return JSON.stringify(value);\r\n}\r\n\r\n/**\r\n * Generates a default example value based on field type\r\n * @param type - The field type\r\n * @returns A default example value\r\n */\r\nfunction generateDefaultExample(type: string): string {\r\n  switch (type) {\r\n    case \"string\":\r\n      return \"Example Text\";\r\n    case \"number\":\r\n      return \"123\";\r\n    case \"boolean\":\r\n      return \"true\";\r\n    case \"email\":\r\n      return \"example@email.com\";\r\n    case \"date\":\r\n      return \"2024-01-01\";\r\n    default:\r\n      return \"Example Value\";\r\n  }\r\n}\r\n\r\n/**\r\n * Escapes CSV values that contain commas, quotes, or newlines\r\n * @param value - The value to escape\r\n * @returns The escaped value\r\n */\r\nfunction escapeCsvValue(value: string): string {\r\n  // If the value contains comma, quote, or newline, wrap it in quotes and escape internal quotes\r\n  if (value.includes(\",\") || value.includes('\"') || value.includes(\"\\n\")) {\r\n    return `\"${value.replace(/\"/g, '\"\"')}\"`;\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * Downloads a CSV file with the given content and filename\r\n * @param content - The CSV content\r\n * @param filename - The filename for the download (default: \"template.csv\")\r\n */\r\nexport function downloadCsvTemplate(\r\n  content: string,\r\n  filename: string = \"template.csv\"\r\n): void {\r\n  // Create a blob with the CSV content\r\n  const blob = new Blob([content], { type: \"text/csv;charset=utf-8;\" });\r\n\r\n  // Create a download link\r\n  const link = document.createElement(\"a\");\r\n  const url = URL.createObjectURL(blob);\r\n\r\n  link.setAttribute(\"href\", url);\r\n  link.setAttribute(\"download\", filename);\r\n  link.style.visibility = \"hidden\";\r\n\r\n  // Add to DOM, click, and remove\r\n  document.body.appendChild(link);\r\n  link.click();\r\n  document.body.removeChild(link);\r\n\r\n  // Clean up the URL object\r\n  URL.revokeObjectURL(url);\r\n}\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/utils/template-generator.ts"
    },
    {
      "path": "src/features/csv-flow/components/review-step/index.tsx",
      "content": "import { Button } from \"@/components/ui/button\";\r\nimport { Checkbox } from \"@/components/ui/checkbox\";\r\nimport { Label } from \"@/components/ui/label\";\r\nimport { Switch } from \"@/components/ui/switch\";\r\nimport { addErrorsToData } from \"../../utils/map-utils\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { TooltipProvider } from \"@/components/ui/tooltip\";\r\nimport {\r\n  ColumnDef,\r\n  ColumnFiltersState,\r\n  flexRender,\r\n  getCoreRowModel,\r\n  getSortedRowModel,\r\n  RowData,\r\n  useReactTable,\r\n} from \"@tanstack/react-table\";\r\nimport { Loader, Trash } from \"lucide-react\";\r\nimport { useMemo, useRef, useState } from \"react\";\r\nimport { toast } from \"sonner\";\r\nimport {\r\n  CustomFieldReturnType,\r\n  FieldConfig,\r\n  FieldMappingItem,\r\n  FieldStatus,\r\n  Meta,\r\n  UpdateDataType,\r\n} from \"../../types\";\r\nimport { DataTableColumnHeader } from \"./data-table-header\";\r\nimport { EditableCell } from \"./editable-cell\";\r\nimport { TableBody } from \"./table-body\";\r\n\r\ndeclare module \"@tanstack/react-table\" {\r\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n  interface TableMeta<TData extends RowData> {\r\n    updateData: UpdateDataType;\r\n  }\r\n}\r\n\r\ntype ReviewStepProps = {\r\n  fields: FieldConfig[];\r\n  data: (Record<string, unknown> & Meta)[];\r\n  fieldMappings: FieldMappingItem[];\r\n  enableCustomFields?: boolean;\r\n  customFieldReturnType?: CustomFieldReturnType;\r\n  onImport: (data: Record<string, unknown>[]) => void;\r\n  handleCloseDialog: () => void;\r\n};\r\n\r\nexport function ReviewStep(props: ReviewStepProps) {\r\n  const {\r\n    data,\r\n    fieldMappings,\r\n    fields,\r\n    enableCustomFields,\r\n    customFieldReturnType,\r\n    onImport,\r\n    handleCloseDialog,\r\n  } = props;\r\n\r\n  const [rowData, setRowData] =\r\n    useState<(Record<string, unknown> & Meta)[]>(data);\r\n  const [filterErrors, setFilterErrors] = useState<boolean>(false);\r\n  const [rowSelection, setRowSelection] = useState<Record<string, boolean>>({});\r\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\r\n  const [isImporting, setIsImporting] = useState<boolean>(false);\r\n  const tableContainerRef = useRef<HTMLDivElement>(null);\r\n\r\n  const columns: ColumnDef<Record<string, unknown> & Meta>[] = useMemo<\r\n    ColumnDef<Record<string, unknown> & Meta>[]\r\n  >(() => {\r\n    const mappingColumns = fieldMappings.reduce<\r\n      ColumnDef<Record<string, unknown> & Meta>[]\r\n    >((acc, mapping) => {\r\n      if (\r\n        mapping.status === FieldStatus.Mapped ||\r\n        mapping.status === FieldStatus.Custom\r\n      ) {\r\n        acc.push({\r\n          id: mapping.id,\r\n          header: ({ column }) => (\r\n            <div className=\"pl-2 w-full\">\r\n              <DataTableColumnHeader\r\n                column={column}\r\n                title={\r\n                  mapping.status === FieldStatus.Mapped\r\n                    ? (mapping.displayName ?? mapping.mappedValue)\r\n                    : mapping.mappedValue\r\n                }\r\n              />\r\n            </div>\r\n          ),\r\n          enableSorting: true,\r\n          accessorKey: mapping.mappedValue,\r\n          size: 180,\r\n          minSize: 100,\r\n          cell: ({ getValue, row, table }) => (\r\n            <EditableCell\r\n              initialValue={getValue()}\r\n              row={row}\r\n              updateData={table.options.meta?.updateData}\r\n              columnName={mapping.mappedValue}\r\n              columnId={mapping.id}\r\n            />\r\n          ),\r\n        });\r\n      }\r\n      return acc;\r\n    }, []);\r\n\r\n    return [\r\n      {\r\n        id: \"select\",\r\n        header: ({ table }) => (\r\n          <Checkbox\r\n            checked={\r\n              table.getIsAllPageRowsSelected() ||\r\n              (table.getIsSomePageRowsSelected() && \"indeterminate\")\r\n            }\r\n            onCheckedChange={(value) =>\r\n              table.toggleAllPageRowsSelected(!!value)\r\n            }\r\n            aria-label=\"Select all\"\r\n          />\r\n        ),\r\n        cell: ({ row }) => (\r\n          <div className=\"px-2 py-1\">\r\n            <Checkbox\r\n              checked={row.getIsSelected()}\r\n              onCheckedChange={(value) => row.toggleSelected(!!value)}\r\n              aria-label=\"Select row\"\r\n            />\r\n          </div>\r\n        ),\r\n        size: 48,\r\n        minSize: 48,\r\n        enableResizing: false,\r\n      },\r\n      ...mappingColumns,\r\n    ];\r\n  }, [fieldMappings]);\r\n\r\n  const filteredData = useMemo(() => {\r\n    if (!filterErrors) return rowData;\r\n    return rowData.filter(\r\n      (row) =>\r\n        row.__errors &&\r\n        Object.values(row.__errors).some((err) => err.level === \"error\")\r\n    );\r\n  }, [rowData, filterErrors]);\r\n\r\n  const table = useReactTable({\r\n    data: filteredData,\r\n    columns,\r\n    getRowId: (row) => row.__index,\r\n    defaultColumn: {\r\n      minSize: 50,\r\n      maxSize: 600,\r\n    },\r\n    columnResizeMode: \"onChange\",\r\n    state: {\r\n      rowSelection,\r\n      columnFilters,\r\n    },\r\n    onColumnFiltersChange: setColumnFilters,\r\n    onRowSelectionChange: setRowSelection,\r\n    getCoreRowModel: getCoreRowModel(),\r\n    getSortedRowModel: getSortedRowModel(),\r\n    meta: {\r\n      updateData: async (rowIndex, columnName, value) => {\r\n        const newRowData = rowData.map((row) => {\r\n          if (row.__index === rowIndex) {\r\n            return {\r\n              ...row,\r\n              [columnName]: value,\r\n            };\r\n          }\r\n          return row;\r\n        });\r\n        const newDataWithErrors = await addErrorsToData(\r\n          newRowData,\r\n          fields,\r\n          fieldMappings\r\n        );\r\n        setRowData(newDataWithErrors);\r\n      },\r\n    },\r\n  });\r\n\r\n  const selectedRowIds = useMemo(\r\n    () => Object.keys(rowSelection).filter((id) => rowSelection[id]),\r\n    [rowSelection]\r\n  );\r\n\r\n  const deleteSelectedRows = async () => {\r\n    const newData = rowData.filter(\r\n      (row) => !selectedRowIds.includes(row.__index)\r\n    );\r\n    const newDataWithErrors = await addErrorsToData(\r\n      newData,\r\n      fields,\r\n      fieldMappings\r\n    );\r\n\r\n    setRowData(newDataWithErrors);\r\n    setRowSelection({});\r\n  };\r\n\r\n  const handleImport = async () => {\r\n    const hasErrors = rowData.some(\r\n      (row) =>\r\n        row.__errors &&\r\n        Object.values(row.__errors).some((err) => err.level === \"error\")\r\n    );\r\n\r\n    if (hasErrors) {\r\n      toast.error(\r\n        \"There are rows with errors. Please fix them before importing.\"\r\n      );\r\n      return;\r\n    }\r\n\r\n    setIsImporting(true);\r\n\r\n    try {\r\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n      let cleanedData = rowData.map(({ __index, __errors, ...rest }) => rest);\r\n\r\n      if (enableCustomFields) {\r\n        const customMappings = fieldMappings.filter(\r\n          (mapping) => mapping.status === FieldStatus.Custom\r\n        );\r\n        if (customFieldReturnType === \"object\") {\r\n          cleanedData = cleanedData.map((row) => {\r\n            const customFields: Record<string, unknown> = {};\r\n            for (const mapping of customMappings) {\r\n              const key = mapping.mappedValue;\r\n              if (key in row) {\r\n                customFields[key] = row[key];\r\n                delete row[key];\r\n              }\r\n            }\r\n            return { ...row, customFields };\r\n          });\r\n        } else if (customFieldReturnType === \"json\") {\r\n          cleanedData = cleanedData.map((row) => {\r\n            const customFields: Record<string, unknown> = {};\r\n            for (const mapping of customMappings) {\r\n              const key = mapping.mappedValue;\r\n              if (key in row) {\r\n                customFields[key] = row[key];\r\n                delete row[key];\r\n              }\r\n            }\r\n            return { ...row, customFields: JSON.stringify(customFields) };\r\n          });\r\n        }\r\n      }\r\n\r\n      onImport(cleanedData);\r\n      handleCloseDialog();\r\n      toast.success(\"Data imported successfully!\");\r\n      setIsImporting(false);\r\n    } catch (error) {\r\n      toast.error(\"Error importing data: \" + (error as Error)?.message);\r\n      setIsImporting(false);\r\n    }\r\n  };\r\n\r\n  const columnSizeVars = useMemo(() => {\r\n    const headers = table.getFlatHeaders();\r\n    const colSizes: { [key: string]: number } = {};\r\n    for (let i = 0; i < headers.length; i++) {\r\n      const header = headers[i]!;\r\n      colSizes[`--header-${header.id}-size`] = header.getSize();\r\n      colSizes[`--col-${header.column.id}-size`] = header.column.getSize();\r\n    }\r\n    return colSizes;\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [table.getState().columnSizingInfo, table.getState().columnSizing]);\r\n\r\n  return (\r\n    <TooltipProvider>\r\n      <div className=\"flex flex-col h-full\">\r\n        {/* Top controls: Filter and Delete */}\r\n        <div className=\"flex flex-wrap gap-4 justify-between items-center mb-4\">\r\n          <div>\r\n            <h2 className=\"text-2xl font-semibold\">Review Your Mapped Data</h2>\r\n            <p className=\"text-sm text-muted-foreground\">\r\n              Please verify the data below. You can update any field, select\r\n              rows to discard, or filter to display only rows with errors before\r\n              finalizing the import.\r\n            </p>\r\n          </div>\r\n          <div className=\"flex gap-4 items-center\">\r\n            <Label className=\"flex gap-2 items-center\">\r\n              <span>Show rows with errors</span>\r\n              <Switch\r\n                checked={filterErrors}\r\n                onCheckedChange={(e: boolean) => {\r\n                  setFilterErrors(e);\r\n                  setRowSelection({});\r\n                }}\r\n              />\r\n            </Label>\r\n\r\n            <Button\r\n              variant=\"ghost\"\r\n              size=\"sm\"\r\n              onClick={deleteSelectedRows}\r\n              className=\"text-destructive hover:text-destructive hover:bg-destructive/5\"\r\n              disabled={!selectedRowIds.length}\r\n            >\r\n              <Trash className=\"size-3\" />\r\n              Delete Selected Rows\r\n            </Button>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Table container */}\r\n        <div\r\n          className=\"overflow-auto relative w-full text-sm rounded-md border grow scrollbar-thin scrollbar-thumb-muted-foreground/15 scrollbar-track-muted\"\r\n          ref={tableContainerRef}\r\n        >\r\n          <table\r\n            className=\"grid w-full text-sm caption-bottom\"\r\n            style={columnSizeVars}\r\n          >\r\n            <thead className=\"[&_tr]:border-b bg-background z-10 grid sticky top-0\">\r\n              {table.getHeaderGroups().map((headerGroup) => (\r\n                <tr\r\n                  key={headerGroup.id}\r\n                  className=\"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted flex w-full\"\r\n                >\r\n                  {headerGroup.headers.map((header) => (\r\n                    <th\r\n                      style={{\r\n                        // width: header.getSize(),\r\n                        width: `calc(var(--header-${header?.id}-size) * 1px)`,\r\n                      }}\r\n                      className=\"h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px] flex items-center relative group/th\"\r\n                      key={header.id}\r\n                    >\r\n                      {header.isPlaceholder\r\n                        ? null\r\n                        : flexRender(\r\n                            header.column.columnDef.header,\r\n                            header.getContext()\r\n                          )}\r\n                      <div\r\n                        className={cn({\r\n                          \"absolute top-0 right-0 cursor-col-resize w-1.5 h-full bg-muted-foreground/30 hover:bg-muted-foreground/50 rounded-lg opacity-0 group-hover/th:opacity-100 transition-opacity\":\r\n                            header.column.getCanResize(),\r\n                        })}\r\n                        {...{\r\n                          onDoubleClick: () => header.column.resetSize(),\r\n                          onMouseDown: header.getResizeHandler(),\r\n                          onTouchStart: header.getResizeHandler(),\r\n                        }}\r\n                      />\r\n                    </th>\r\n                  ))}\r\n                </tr>\r\n              ))}\r\n            </thead>\r\n            <TableBody\r\n              table={table}\r\n              tableContainerRef={tableContainerRef}\r\n              columnsLength={columns.length}\r\n            />\r\n          </table>\r\n        </div>\r\n\r\n        {/* Continue button */}\r\n        <div className=\"flex justify-between items-center mt-4\">\r\n          <div className=\"text-sm text-muted-foreground\">\r\n            Total Rows: {rowData.length}\r\n            {selectedRowIds.length > 0 && (\r\n              <span className=\"ml-4\">\r\n                Selected Rows: {selectedRowIds.length}\r\n              </span>\r\n            )}\r\n          </div>\r\n\r\n          <div className=\"flex justify-end\">\r\n            {isImporting && (\r\n              <p className=\"flex gap-2 items-center mr-4 text-sm text-muted-foreground\">\r\n                <Loader className=\"animate-spin size-4\" /> Processing...\r\n              </p>\r\n            )}\r\n            <Button disabled={isImporting} onClick={handleImport}>\r\n              Import\r\n            </Button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </TooltipProvider>\r\n  );\r\n}\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/components/review-step/index.tsx"
    },
    {
      "path": "src/features/csv-flow/components/review-step/data-table-header.tsx",
      "content": "import { SelectIcon } from \"@radix-ui/react-select\";\nimport type { Column } from \"@tanstack/react-table\";\nimport { ArrowDown, ArrowUp, ChevronsUpDown } from \"lucide-react\";\n\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n} from \"@/components/ui/select\";\nimport { cn } from \"@/lib/utils\";\n\ninterface DataTableColumnHeaderProps<TData, TValue>\n  extends React.HTMLAttributes<HTMLDivElement> {\n  column: Column<TData, TValue>;\n  title: string;\n}\n\nexport function DataTableColumnHeader<TData, TValue>(\n  props: DataTableColumnHeaderProps<TData, TValue>\n) {\n  const { column, title, className } = props;\n\n  if (!column.getCanSort() && !column.getCanHide()) {\n    return <div className={cn(className)}>{title}</div>;\n  }\n\n  const ascValue = `${column.id}-asc`;\n  const descValue = `${column.id}-desc`;\n  const hideValue = `${column.id}-hide`;\n\n  return (\n    <div className={cn(\"flex items-center gap-2\", className)}>\n      <Select\n        value={\n          column.getIsSorted() === \"desc\"\n            ? descValue\n            : column.getIsSorted() === \"asc\"\n            ? ascValue\n            : undefined\n        }\n        onValueChange={(value) => {\n          if (value === ascValue) column.toggleSorting(false);\n          else if (value === descValue) column.toggleSorting(true);\n          else if (value === hideValue) column.toggleVisibility(false);\n        }}\n      >\n        <SelectTrigger\n          aria-label={\n            column.getIsSorted() === \"desc\"\n              ? \"Sorted descending. Click to sort ascending.\"\n              : column.getIsSorted() === \"asc\"\n              ? \"Sorted ascending. Click to sort descending.\"\n              : \"Not sorted. Click to sort ascending.\"\n          }\n          className=\"-ml-3 h-8 max-w-fit border-none text-xs hover:bg-accent hover:text-accent-foreground data-[state=open]:bg-accent [&>svg:last-child]:hidden\"\n        >\n          {/* <div className=\"flex-1 min-w-0\"> */}\n          <span className=\"flex-1 truncate\">{title}</span>\n          {/* </div> */}\n          <SelectIcon asChild className=\"shrink-0\">\n            {column.getCanSort() && column.getIsSorted() === \"desc\" ? (\n              <ArrowDown className=\"ml-2.5 size-3\" aria-hidden=\"true\" />\n            ) : column.getIsSorted() === \"asc\" ? (\n              <ArrowUp className=\"ml-2.5 size-3\" aria-hidden=\"true\" />\n            ) : (\n              <ChevronsUpDown className=\"ml-2.5 size-3\" aria-hidden=\"true\" />\n            )}\n          </SelectIcon>\n        </SelectTrigger>\n        <SelectContent align=\"start\">\n          {column.getCanSort() && (\n            <>\n              <SelectItem value={ascValue}>\n                <span className=\"flex items-center\">\n                  <ArrowUp\n                    className=\"mr-2 size-3.5 text-muted-foreground/70\"\n                    aria-hidden=\"true\"\n                  />\n                  Asc\n                </span>\n              </SelectItem>\n              <SelectItem value={descValue}>\n                <span className=\"flex items-center\">\n                  <ArrowDown\n                    className=\"mr-2 size-3.5 text-muted-foreground/70\"\n                    aria-hidden=\"true\"\n                  />\n                  Desc\n                </span>\n              </SelectItem>\n            </>\n          )}\n          {/* {column.getCanHide() && (\n            <SelectItem value={hideValue}>\n              <span className=\"flex items-center\">\n                <EyeOff\n                  className=\"mr-2 size-3.5 text-muted-foreground/70\"\n                  aria-hidden=\"true\"\n                />\n                Hide\n              </span>\n            </SelectItem>\n          )} */}\n        </SelectContent>\n      </Select>\n    </div>\n  );\n}\n",
      "type": "registry:block",
      "target": "components/csv-flow/components/review-step/data-table-header.tsx"
    },
    {
      "path": "src/features/csv-flow/components/review-step/editable-cell.tsx",
      "content": "import { Row } from \"@tanstack/react-table\";\r\nimport { Meta, UpdateDataType } from \"../../types\";\r\nimport { useEffect, useState } from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport {\r\n  Tooltip,\r\n  TooltipContent,\r\n  TooltipTrigger,\r\n} from \"@/components/ui/tooltip\";\r\nimport { toHeaderCase } from \"../../utils/helpers\";\r\n\r\ntype Props = {\r\n  initialValue: unknown;\r\n  updateData?: UpdateDataType;\r\n  row: Row<Record<string, unknown> & Meta>;\r\n  columnId: string;\r\n  columnName: string;\r\n};\r\n\r\nexport function EditableCell(props: Props) {\r\n  const { initialValue, updateData, row, columnId, columnName } = props;\r\n\r\n  const [value, setValue] = useState(initialValue);\r\n\r\n  const onBlur = () => {\r\n    if (value !== initialValue) {\r\n      updateData?.(row.original.__index, columnName, value);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    setValue(initialValue);\r\n  }, [initialValue]);\r\n\r\n  const hasError = row.original.__errors?.[columnName];\r\n  const isError = !!hasError && hasError.level === \"error\";\r\n  const isWarning = !!hasError && hasError.level === \"warning\";\r\n  const isInfo = !!hasError && hasError.level === \"info\";\r\n\r\n  const displayValue = typeof value === \"boolean\" ? String(value) : value;\r\n\r\n  return (\r\n    <div\r\n      className={cn(\"border border-transparent\", {\r\n        \"border-l-destructive border-l-2 bg-destructive/5\": isError,\r\n        \"border-l-yellow-500 border-l-2 bg-yellow-500/5\": isWarning,\r\n        \"border-l-blue-500 border-l-2 bg-blue-500/5\": isInfo,\r\n      })}\r\n    >\r\n      {hasError ? (\r\n        <Tooltip>\r\n          <TooltipTrigger asChild>\r\n            <input\r\n              id={`${columnId}-${row.original.__index}}`}\r\n              className=\"w-full px-3 py-1 leading-normal align-middle bg-transparent text-text focus:outline-none focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring\"\r\n              value={displayValue ? String(displayValue) : \"\"}\r\n              onChange={(e) => setValue(e.target.value)}\r\n              onBlur={onBlur}\r\n            />\r\n          </TooltipTrigger>\r\n          <TooltipContent>\r\n            <p>\r\n              <span className=\"font-medium\">\r\n                {toHeaderCase(hasError.level)}\r\n              </span>\r\n              : {hasError.message}\r\n            </p>\r\n          </TooltipContent>\r\n        </Tooltip>\r\n      ) : (\r\n        <input\r\n          id={`${columnId}-${row.original.__index}}`}\r\n          className=\"w-full px-3 py-1 leading-normal align-middle bg-transparent text-text focus:outline-none focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring\"\r\n          value={displayValue ? String(displayValue) : \"\"}\r\n          onChange={(e) => setValue(e.target.value)}\r\n          onBlur={onBlur}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/components/review-step/editable-cell.tsx"
    },
    {
      "path": "src/features/csv-flow/components/review-step/table-body-row.tsx",
      "content": "import { flexRender, Row } from \"@tanstack/react-table\";\r\nimport { VirtualItem, Virtualizer } from \"@tanstack/react-virtual\";\r\nimport { Meta } from \"../../types\";\r\n\r\ntype TableBodyRowProps = {\r\n  row: Row<Record<string, unknown> & Meta>;\r\n  virtualRow: VirtualItem;\r\n  rowVirtualizer: Virtualizer<HTMLDivElement, HTMLTableRowElement>;\r\n};\r\n\r\nexport function TableBodyRow(props: TableBodyRowProps) {\r\n  const { row, virtualRow, rowVirtualizer } = props;\r\n\r\n  return (\r\n    <tr\r\n      data-index={virtualRow.index}\r\n      ref={(node) => rowVirtualizer.measureElement(node)}\r\n      style={{\r\n        transform: `translateY(${virtualRow.start}px)`,\r\n      }}\r\n      key={row.id}\r\n      className=\"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted flex absolute w-full\"\r\n      data-state={row.getIsSelected() && \"selected\"}\r\n    >\r\n      {row.getVisibleCells().map((cell) => (\r\n        <td\r\n          className=\"align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]\"\r\n          key={cell.id}\r\n          style={{\r\n            // width: `${cell.column.getSize()}px`,\r\n            minWidth: `${cell.column.columnDef.minSize}px`,\r\n            width: `calc(var(--col-${cell.column.id}-size) * 1px)`,\r\n          }}\r\n        >\r\n          {flexRender(cell.column.columnDef.cell, cell.getContext())}\r\n        </td>\r\n      ))}\r\n    </tr>\r\n  );\r\n}\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/components/review-step/table-body-row.tsx"
    },
    {
      "path": "src/features/csv-flow/components/review-step/table-body.tsx",
      "content": "import { Table } from \"@tanstack/react-table\";\r\nimport { Meta } from \"../../types\";\r\nimport { useVirtualizer } from \"@tanstack/react-virtual\";\r\nimport { useCallback, useEffect } from \"react\";\r\nimport { TableBodyRow } from \"./table-body-row\";\r\n\r\ntype TableBodyProps = {\r\n  table: Table<Record<string, unknown> & Meta>;\r\n  tableContainerRef: React.RefObject<HTMLDivElement>;\r\n  columnsLength: number;\r\n};\r\n\r\nexport function TableBody(props: TableBodyProps) {\r\n  const { table, tableContainerRef, columnsLength } = props;\r\n\r\n  const { rows } = table.getRowModel();\r\n\r\n  const rowVirtualizer = useVirtualizer<HTMLDivElement, HTMLTableRowElement>({\r\n    count: rows.length,\r\n    estimateSize: useCallback(() => 34, []),\r\n    getScrollElement: () => tableContainerRef.current,\r\n    measureElement:\r\n      typeof window !== \"undefined\" &&\r\n      navigator.userAgent.indexOf(\"Firefox\") === -1\r\n        ? (element) => element?.getBoundingClientRect().height\r\n        : undefined,\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (tableContainerRef.current) {\r\n      rowVirtualizer.measure();\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [tableContainerRef.current]);\r\n\r\n  const virtualizedRowItems = rowVirtualizer.getVirtualItems();\r\n\r\n  return (\r\n    <tbody\r\n      className=\"[&_tr:last-child]:border-0 relative grid\"\r\n      style={{\r\n        height: `${rowVirtualizer.getTotalSize()}px`,\r\n      }}\r\n    >\r\n      {virtualizedRowItems.length ? (\r\n        virtualizedRowItems.map((virtualRow) => {\r\n          const row = rows[virtualRow.index];\r\n\r\n          return (\r\n            <TableBodyRow\r\n              key={row.id}\r\n              row={row}\r\n              virtualRow={virtualRow}\r\n              rowVirtualizer={rowVirtualizer}\r\n            />\r\n          );\r\n        })\r\n      ) : (\r\n        <tr>\r\n          <td\r\n            colSpan={columnsLength}\r\n            className=\"h-24 p-4 text-center text-muted-foreground\"\r\n          >\r\n            No results.\r\n          </td>\r\n        </tr>\r\n      )}\r\n    </tbody>\r\n  );\r\n}\r\n",
      "type": "registry:block",
      "target": "components/csv-flow/components/review-step/table-body.tsx"
    }
  ]
}